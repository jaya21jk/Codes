Leetcode 862
public int shortestSubarray(int[] nums, int k) {
        int n = nums.length;
        long sum = 0;
        Deque<long[]> dq = new LinkedList<>(); //(index,sum) pairs
        int ans = Integer.MAX_VALUE;
        for(int i = 0 ;i < n; i++) {
            sum += nums[i]; //s2

            // Maintain sum in dq as increasing order

            while(dq.size() > 0 && dq.peekLast()[1] >= sum){
                dq.removeLast();
            }
            dq.addLast(new long[]{i,sum});

            //check sum >= k

            if(sum >= k) ans = Math.min(ans,i+1);

            //Check any possiblele s2 - s1;
            while(dq.size() > 0 && sum-dq.peekFirst()[1] >= k){
                    ans = Math.min(ans,i-(int)dq.peekFirst()[0]);
                    dq.removeFirst();
            }
        }
        if(ans == Integer.MAX_VALUE) return -1;
        return ans;
    }
    
    /////   69. Sqrt(x)   //////
    
    class Solution {
    public int mySqrt(int x) {
        // int ans = 0;
        // while(ans * ans < x){
        //     ans++;
        // }
        // if(ans * ans == x) return ans;
        // return ans-1;
        if(x == 0) return 0;
        if(x == 1) return 1;
        int start = 1;
        int end = x/2;
        int ans = -1;
        while(start <= end){
            int mid = start + (end-start)/2;
            if(mid == x / mid) return mid;
            else if(mid < x/mid ) {
                ans = mid;
                start = mid+1;
            }
            else end = mid-1;      
        }
        return ans;
    }
}

////////// Triangular Number GFG /////////////////

class Solution {
    int isTriangular(int N){
        int start = 1;
        int end = N;
        while(start <= end){
            int mid = start + (end-start)/2;
            int num = (mid * (mid+1))/2;
            if(num == N) return 1;
            else if(num > N) end = mid-1;
            else start = mid+1;
        }
        return 0;
    }
}
