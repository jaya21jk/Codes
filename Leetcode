Leetcode 862
public int shortestSubarray(int[] nums, int k) {
        int n = nums.length;
        long sum = 0;
        Deque<long[]> dq = new LinkedList<>(); //(index,sum) pairs
        int ans = Integer.MAX_VALUE;
        for(int i = 0 ;i < n; i++) {
            sum += nums[i]; //s2

            // Maintain sum in dq as increasing order

            while(dq.size() > 0 && dq.peekLast()[1] >= sum){
                dq.removeLast();
            }
            dq.addLast(new long[]{i,sum});

            //check sum >= k

            if(sum >= k) ans = Math.min(ans,i+1);

            //Check any possiblele s2 - s1;
            while(dq.size() > 0 && sum-dq.peekFirst()[1] >= k){
                    ans = Math.min(ans,i-(int)dq.peekFirst()[0]);
                    dq.removeFirst();
            }
        }
        if(ans == Integer.MAX_VALUE) return -1;
        return ans;
    }
    
    /////   69. Sqrt(x)   //////
    
    class Solution {
    public int mySqrt(int x) {
        // int ans = 0;
        // while(ans * ans < x){
        //     ans++;
        // }
        // if(ans * ans == x) return ans;
        // return ans-1;
        if(x == 0) return 0;
        if(x == 1) return 1;
        int start = 1;
        int end = x/2;
        int ans = -1;
        while(start <= end){
            int mid = start + (end-start)/2;
            if(mid == x / mid) return mid;
            else if(mid < x/mid ) {
                ans = mid;
                start = mid+1;
            }
            else end = mid-1;      
        }
        return ans;
    }
}

////////// Triangular Number GFG /////////////////

class Solution {
    int isTriangular(int N){
        int start = 1;
        int end = N;
        while(start <= end){
            int mid = start + (end-start)/2;
            int num = (mid * (mid+1))/2;
            if(num == N) return 1;
            else if(num > N) end = mid-1;
            else start = mid+1;
        }
        return 0;
    }
}

//////////////////   1011. Capacity To Ship Packages Within D Days /////////////////////////


class Solution {
    private boolean isPossible(int[] weights,int beltWeight,int days){
        int n = weights.length;
        int currweight = 0;
        int currDay = 1;
        for(int i=0; i < n ; i++){
            currweight += weights[i];
            if(currweight > beltWeight){
                currweight = weights[i];
                currDay++;
            }
        }
        return currDay <= days;
    }
    public int shipWithinDays(int[] weights, int D) {

        // int maxWeight = Integer.MIN_VALUE;
        // int totalWeight = 0;
        // for(int ele : weights){
        //     maxWeight = Math.max(maxWeight,ele);
        //     totalWeight += ele;
        // }

        // int start = maxWeight;
        // int end = totalWeight;
        // int ans = -1;

        // while(start <= end){
        //     int mid = (start+end)/2;
        //     if(isPossible(weights,mid,days)){
        //         ans = mid;
        //         end = mid-1;
        //     }
        //     else start = mid+1;
        // }
        // return ans;

        int left = 0, right = 0;
        for (int w: weights) {
            left = Math.max(left, w);
            right += w ;
        }
        while (left < right) {
            int mid = (left + right) / 2, need = 1, cur = 0;
            for (int w: weights) {
                if (cur + w > mid) {
                    need += 1;
                    cur = 0;
                }
                cur += w;
            }
            if (need > D) left = mid + 1;
            else right = mid;
        }
        return left;
    }
}

/////////////  1482. Minimum Number of Days to Make m Bouquets ///////////////////

class Solution {

    private boolean isPossible(int[] boomDay, int currDay, int m, int k){
        int flowers = 0;
        int boques = 0;
        int n = boomDay.length;

        for(int i = 0 ; i < n ; i++){
            if(boomDay[i] <= currDay) flowers++;
            else flowers = 0;

            if(flowers == k){
                flowers = 0;
                boques++;
                if(boques == m) return true;
            }
        }
        return false;
    }

    public int minDays(int[] bloomDay, int m, int k) {
        int minDay = Integer.MAX_VALUE;
        int maxDay = Integer.MIN_VALUE;
        int n = bloomDay.length;

       // if( m * k > n) return -1;
        
        for(int i=0 ; i < n ; i++){
            minDay = Math.min(minDay,bloomDay[i]);
            maxDay = Math.max(maxDay,bloomDay[i]);
        }

        int start = minDay;
        int end = maxDay;
        int ans = -1;

        while(start <= end){
            int mid = (start+end) / 2;
            if(isPossible(bloomDay , mid, m , k)){
                ans = mid;
                end = mid-1;
            }
            else start = mid+1;
        }
        return ans;
    }
}
